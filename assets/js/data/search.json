[ { "title": "[Vue.js] SVG 引入與 Typescript 型別設定", "url": "/posts/vue-svg-import/", "categories": "Vue.js, Vue, Vite", "tags": "Node.js, Javascript, Vue.js, Vue3, Vite, Typescript, SVG", "date": "2025-08-14 16:00:00 +0800", "content": "❌錯誤示範 如何在vue專案裡使用 svg 檔案，最直覺的做法： &lt;template&gt; &lt;svg&gt; &lt;use href=\"./assets/penguin-svgrepo-com.svg\" width=\"50%\" height=\"50%\" /&gt; &lt;/svg&gt; &lt;/template&gt; 開發階段只要注意路徑正確，就能正常顯示。 但編譯到正式環境時，這段 &lt;use&gt; 標籤使用了 href=\"data:image/svg+xml,... 來嵌入 SVG 圖片，但這種用法在 &lt;use&gt; 上是無效的，因此圖示不會正確顯示。 改用圖片 &lt;img&gt; 來處理或許可以解決： &lt;img src=\"data:image/svg+xml,&lt;svg ...&gt;...\" /&gt; 雖然這樣瀏覽器就會把它當成圖片正常顯示，但無法用 CSS 改 fill 或 stroke，可調整性較差。 ✔️解決方法 1. 安裝 vite-svg-loader 及設定 npm install -D vite-svg-loader 接著，vite.config.ts也要增加設定： import svgLoader from 'vite-svg-loader'; export default { plugins: [ svgLoader(), ], // ... }; 2. 新增型別宣告 假設專案並不是使用 Typescript，可以省略這個步驟。 新增 vite-env.d.ts，其主要用途是為 Vite 專案提供型別宣告。它能確保你的 TypeScript 專案能夠正確識別和處理 Vite 特有的功能，而不會報錯。 簡單來說，它就像一個翻譯官，告訴 TypeScript 編譯器：「嘿，Vite 會處理這些特殊檔案，請不要報錯，它們的型別是長這樣。」 // src/vite-env.d.ts declare module '*.svg' { const content: string export default content } 你也可以使用 env.d.ts。但 vite-env.d.ts 的命名方式更明確地表示它是為 Vite 專案服務的。 建議放在 src/ 資料夾的根目錄，Vite 會自動尋找資料夾中的 env.d.ts 或 vite-env.d.ts 檔案，並將其視為專案的型別宣告。 如果你將它放在其他位置，你需要在 tsconfig.json 的 include 或 files 欄位中手動指定它的路徑，確保 TypeScript 編譯器能夠找到它。 3. 使用 svg 最後只要調整引用的方法，可以把 svg 當作一個 component 來使用。 &lt;template&gt; &lt;Penguin /&gt; &lt;/template&gt; &lt;script setup lang=\"ts\"&gt; import Penguin from '@/assets/penguin.svg' &lt;/script&gt; 這樣一來原本支援的 attr 都可以使用，例如： &lt;Penguin width=\"200\" height=\"200\" /&gt; 參考資料： https://www.npmjs.com/package/vite-svg-loader " }, { "title": "[React] JSX 常見語法雷區", "url": "/posts/react-jsx-common-mistakes/", "categories": "React, JSX", "tags": "React, Javascript, JSX", "date": "2025-07-27 16:00:00 +0800", "content": "1. JSX 中 HTML 標籤必須自閉合 HTML 中 input 是 void element，本來不需要閉合標籤。 // ✅ 正確 &lt;input type=\"text\" /&gt; // ❌ 錯誤 &lt;input type=\"text\"&gt; // JSX 會報錯 2. class 要改寫成 className JSX 是 JavaScript，不允許使用 JS 關鍵字 class。 // ✅ 正確 &lt;div className=\"box\" /&gt; // ❌ 錯誤 &lt;div class=\"box\" /&gt; // React 不認得 3. for 要改寫成 htmlFor 表單 label 的 for 在 JSX 中是保留字，要改成 htmlFor： &lt;label htmlFor=\"email\"&gt;Email&lt;/label&gt; 4. JS 表達式要放在 {} 裡 Vue.js template 則使用是雙括號 `` const name = \"Annie\"; // ✅ 正確 &lt;p&gt;Hello, {name}&lt;/p&gt; &lt;h1&gt;{name.toUpperCase()}&lt;/h1&gt; // ❌ 錯誤 &lt;p&gt;Hello, &lt;/p&gt; 5. style 需用物件寫法，且值要加引號或轉成 string style 物件的 key 是 camelCase（如: fontSize），不同於 HTML/CSS 的 kebab-case（如: font-size） // ✅ 正確 &lt;div style= /&gt; // ❌ 錯誤 &lt;div style=\"color: red; font-size: 16px;\" /&gt; // HTML 寫法不支援 雙括號讓解讀困難，因此也把物件先儲存到一個變數中再傳給 style，效果完全一樣。 const config = { color: 'red', fontSize: '16px' }; const element = &lt;div style={config} /&gt; 6. JSX 裡只能回傳單一根元素 必須使用 Fragment // ✅ 正確（使用 &lt;&gt;&lt;/&gt; Fragment） return ( &lt;&gt; &lt;Header /&gt; &lt;Content /&gt; &lt;/&gt; ); // ❌ 錯誤（JSX 中不能 return 兩個平行元素） return ( &lt;Header /&gt; &lt;Content /&gt; ); 7. 事件寫法是駝峰命名，值是函式 非常容易與 HTML 原本的寫法混淆 // ✅ 正確 &lt;button onClick={handleClick}&gt;Click&lt;/button&gt; // ❌ 錯誤 &lt;button onclick=\"handleClick()\"&gt;Click&lt;/button&gt; 8. 條件渲染 在 JSX 中，沒有像 Vue.js 的 v-if 那樣的指令語法，但可以用 JavaScript 表達式來實現相同的功能，或是三元運算或邏輯 (&amp;&amp;) 來達到條件渲染。 {isLoading &amp;&amp; &lt;Loading /&gt;} {isLoggedIn ? &lt;Dashboard /&gt; : &lt;Login /&gt;} 8. 條件式為 0 時，通常是非預期的顯示結果 像這樣 isLoading 為 boolean，True 顯示 Loading。 {isLoading &amp;&amp; &lt;Loading /&gt;} '', null, False 代表否定、不會顯示任何內容，0 雖然也歸類成否定，對 jsx 卻是可以正確顯示在畫面上的值，務必要讓條件輸出成 boolean 來避免問題。 // ✅ 正確 {item.length &gt; 0 &amp;&amp; &lt;List item={item} /&gt;} // ❌ 錯誤 {item.length &amp;&amp; &lt;List item={item} /&gt;} // 得到的結果是 {0} 10. 列表渲染 JSX 本質上就是 JavaScript + HTML 的混合語法，所有邏輯請交給 JS 處理，Vue.js 的 v-for 可以對應到 .map()，同樣要設定 key 屬性，其值必須唯一。 {items.map((item, index) =&gt; ( &lt;li key={index}&gt;{item}&lt;/li&gt; ))} " }, { "title": "Vue3.2 &lt;script setup&gt; 實作 TodoMVC", "url": "/posts/vue3-script-setup/", "categories": "Vue.js, Vue", "tags": "Vue.js, Vue3, Node.js, Javascript", "date": "2022-07-25 16:00:00 +0800", "content": "Vue3.2開始將 &lt;script setup&gt; 移除experimental status，和setup()區別在有許多 option API 有了替代方案，props, emit 也可以寫在 setup，variable 或 function 也不需要透過 return 才能讓 &lt;template&gt; 使用，哇！寫法怎麼好像有點既是感呢 下面會利用 TodoMVC 的練習，比較與統整 &lt;script setup&gt; 和 setup() 常用的方法的差異。 TodoMVC 完整程式碼上傳至 Github (連結)。 data setup() &lt;script&gt; import { ref } from 'vue'; export default { setup() { const newTodo = ref(undefined); return { newTodo, }; }, } &lt;/script&gt; &lt;script setup&gt; 宣告 ref 沒有差異，差在需不需要 return &lt;script setup&gt; import { ref } from 'vue'; const newTodo = ref(undefined); &lt;/script&gt; component &lt;template&gt; &lt;TodoListEditor /&gt; &lt;/template&gt; setup() &lt;script&gt; import TodoListEditor from 'components/TodoListEditor.vue'; export default { components: { TodoListEditor, }, } &lt;/script&gt; &lt;script setup&gt; import 之後就可以直接在 &lt;template&gt; 使用 &lt;script setup&gt; import TodoListEditor from 'components/TodoListEditor.vue'; &lt;/script&gt; props setup() &lt;script&gt; export default { props: { todoList: { required: true, type: Array, }, }, } &lt;/script&gt; &lt;script setup&gt; defineProps 裡面內容與之前 props 相同 &lt;script setup&gt; const props = defineProps({ todoList: { required: true, type: Array, }, }); &lt;/script&gt; emit setup() &lt;script&gt; export default { emits: ['remove:todo', 'update:todo'], setupt(props, {emit}) { function removeTodoItem(id){ emit('remove:todo', id); } }, } &lt;/script&gt; &lt;script setup&gt; defineEmits 裡面內容與之前 emits 相同 &lt;script setup&gt; const emit = defineEmits(['remove:todo', 'update:todo']); function removeTodoItem(id){ emit('remove:todo', id); } &lt;/script&gt; directive directive是所有寫法中我最不適應的，底下是頁面載入時可以有 autofocus 的效果，可以根據不同 lifecyle 定義，利如 mouted &lt;input v-model=\"newTodo\" v-focus&gt; setup() &lt;script&gt; const focus = { mounted: el =&gt; el.focus(), }; export default { directives: { focus, }, } &lt;/script&gt; &lt;script setup&gt; &lt;script setup&gt; const vFocus = { mounted: el =&gt; el.focus(), }; &lt;/script&gt; lifecyle 基本上沒有什麼區別 setup() &lt;script&gt; import {onMounted} from 'vue'; export default { setup() { onMounted(() =&gt; { // to something }); }, } &lt;/script&gt; &lt;script setup&gt; &lt;script setup&gt; import {onMounted} from 'vue'; onMounted(() =&gt; { // to something }); &lt;/script&gt; " }, { "title": "mocha + webpack 的 Vue3 元件單元測試", "url": "/posts/vue3-unit-test-by-mocha-webpack/", "categories": "Unit Test, Mocha, Vue", "tags": "Node.js, Javascript, Vue.js, Vue3, Mocha, Webpack5, Unit Test, Chai", "date": "2022-07-24 16:00:00 +0800", "content": "先說結論，我認為不適合用 mocha 進行 vue3 單元測試(@vue/test-utils)，反覆查了很久的資料，相關的套件支援度不足等有重重的障礙，根據 @vue/test-utils 目前提供的測試範例，選擇 Vitest 會更適合。 完整程式碼上傳至 Github (連結)。 一、安裝 首先，第一個問題就是 vue 的版本不能太新，目前只支援 3.0.7，因此對應安裝了相同版本的 @vue/server-renderer npm install --save-dev @vue/server-renderer@3.0.7 再來請安裝 webpck 和 mocha，mochapack，mochapack 是用來讀取 webpack 設定將元件 render 出來的套件，可支援 webpack5 和 mocha 9 npm install --save-dev webpack mocha mochapack 其他有兩個類似的套件： mocha-webpack: mocha: ‘&gt;=4 &lt;=5’ webpack: ‘^4.0.0’ instant-mocha: mocha: ‘^6.1.4 || ^8.3.2’ webpack: ‘^4.40.0 || ^5.0.0’ mochapack 是由 mocha-webpack 延伸而來的，三者用法都非常接近，但上述兩個對 webpack 和 mocha 版本的支援度都比 mochapack 差 再來請安裝 vue3 官方的元件測試套件 @vue/test-utils npm install --save-dev @vue/test-utils mocha 不像是 jest 已經內建支援 jsdom、assertion ，所以要另外安裝 npm install --save-dev webpack-node-externals jsdom-global npm install --save-dev expect 二、設定 新增測試專用的 webpack 設定檔 webpack.config-test.js const nodeExternals = require('webpack-node-externals'); const { VueLoaderPlugin } = require('vue-loader'); module.exports = { mode: 'development', target: 'node', // webpack should compile node compatible code externals: [nodeExternals()], // in order to ignore all modules in node_modules folder devtool: 'inline-cheap-module-source-map', module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', }, { test: /\\.css$/i, use: ['style-loader', 'css-loader'], }, ], }, plugins: [ new VueLoaderPlugin(), ], }; 設定 jsdom 設定檔 src/tests/setup.js require('jsdom-global')(); 最後，請到 package.json 設定 script 指令 { \"scripts\": { \"test\": \"npx mochapack --webpack-config webpack.config-test.js --require src/tests/setup.js src/tests/**/*.spec.js\", } } Usage: mochapack [options] [&lt;file|directory|glob&gt; …] Options 　–webpack-config　　path to webpack-config file 　–require, -r　　　　require the given module 三、執行 新增測試(範例請參考 Counter.spec.js)後,執行指令即可 npm run test 四、限制 無法支援最新 vue3 無法支援目前 vue 最新版本 3.2.37，發現底下錯誤訊息 ReferenceError: SVGElement is not defined 無法支援 SFC 無法支援 SFC ，發現底下警告訊息: [Vue warn]: Component is missing template or render function. 參考文件 用 Mocha 和 webpack 測試單文件組件 mochapack 文件 taro新建vue3项目后，编译成小程序端报错ReferenceError: SVGElement is not defined " }, { "title": "Github Action 自動部署 github-pages", "url": "/posts/auto-deploy-github-pages/", "categories": "CI/CD, Github Action", "tags": "CI/CD, Github Action", "date": "2022-06-28 16:00:00 +0800", "content": "Github pages 適合展示靜態頁面，只要在 github 建立 gh-pages 分支，可依據用戶名稱和repo名稱來開啟頁面。 https://[USER_NAME].github.io/[REPO_NAME]/ 以這個專案為例 https://github.com/chenuin/JavaScript30 路徑會是 https://chenuin.github.io/JavaScript30/ 使用 JamesIves/github-pages-deploy-action@v4.3.3 有兩個必填參數： branch: 分支 folder: 目錄，.代表整個repo根目錄 參數詳細說明請參考這裡，在 repo 裡新增 github action (連結): name: Github pages on: # Triggers the workflow on push events but only for the \"master\" branch push: branches: master # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout 🛎️ uses: actions/checkout@v3 - name: Deploy 🚀 uses: JamesIves/github-pages-deploy-action@v4.3.3 with: branch: gh-pages folder: . token: $ GH_PAT 設定方式，請先至 Settings =&gt; Developer settings =&gt; Personal access tokens (或下方連結)，按右上角新增Token，scopes 可直接勾選 repo 並將Token複製。 https://github.com/settings/tokens 再到專案的 Settings =&gt; Secrets =&gt; Actions (或下方連結)，按右上角新增，命名 GH_PAT 並將剛剛複製的Token貼上。 https://github.com/[USER_NAME]/[REPO_NAME]/settings/secrets/actions 相關文章 Github Actions 自動 Jekyll 專案部屬 Github Pages [Github] 在github.io建立免費的網站 " }, { "title": "【升版指南】Vue3 非兼容的特性 v-model 跟 Vue2 完全不一樣", "url": "/posts/v-model-vue3-migration-strategy/", "categories": "Vue.js, Vue", "tags": "Node.js, Javascript, Vue.js, Vue3, Migration Strategy", "date": "2022-06-25 16:00:00 +0800", "content": "Vue2 與 Vue3 比較 vue2 v-model 的使用方式在這篇「[Vue.js] 如何在component自訂v-model」介紹，簡單說就是結合v-model其實綁定了名為 value 的 props 和 input 的 emit事件，因此所謂的 v-model 就是一個父子元件的雙向溝通，在 vue2 兩者是相同的： &lt;input v-model=\"username\"&gt; &lt;input :value=\"username\" @input=\"(value)=&gt;(username=value)\"&gt; 但是！ vue3 props 預設名稱從 value 改為 modelValue ，emit 名稱則從 input 改為 update:modelValue，如果用錯了就無法達成雙向的綁定。 &lt;input v-model=\"username\"&gt; &lt;input :model-value=\"username\" @update:modelValue=\"(value)=&gt;(username=value)\"&gt; 在 vue2 中可以用自訂 model 來自訂 props 和 emit 名稱，在 Vue3 移除不再支援，如果不想使用 modelValue 的話，在 Vue3 可以這樣寫： &lt;MyComponent v-model:username=\"username\" /&gt; &lt;MyComponent :username=\"username\" @update:username=\"(value)=&gt;(username=value)\" /&gt; 元件本身應該增加這個 props,更新時會呼叫 update:username props: { username: { type: String, required: true, }, } 跟 vue2 .sync 有點相似，vue3不再支援 .sync ，寫法會是 v-model:[NAME] 後面 Name 就是想自訂的名稱，更新時 update:[NAME]，以事件名稱來看不算是完全客製，須按照規則觸發向上更新 但這個特性最棒的是支援多組 v-model ，你可以這樣寫： &lt;MyComponent v-model:username=\"username\" v-model:password=\"password\" /&gt; 重點整理 總結將 vue2 升至 vue3，v-model 應該注意三個地方： 不再使用 .sync &lt;MyComponent :username.sync=\"name\" /&gt; &lt;!-- to be replaced with --&gt; &lt;MyComponent v-model:username=\"name\" /&gt; 將所有的 value 和 input 和 modelValue 和 update:modelValue &lt;MyComponent v-model=\"name\" /&gt; export default { props: { modelValue: String, // \"vaule\" is replaced }, emits: ['update:modelValue'], methods: { changeName(name) { this.$emit('update:modelValue', name); // \"input\" is replaced }, }, }; 不再使用 model 直接用 v-model、v-model:[Name] 參考文章: https://v3-migration.vuejs.org/breaking-changes/v-model.html " }, { "title": "Vue3+jest 測試 composable 範例", "url": "/posts/vue3-jest-composable-testing/", "categories": "Unit Test, Jest, Vue.js, Vue", "tags": "Node.js, Javascript, Vue.js, Vue3, Composition API, Unit Test, Jest, Composable", "date": "2022-05-28 16:00:00 +0800", "content": "Composable 與 Mixin 比較 Vue3 的 composable 乍看下和 mixin 用途很類似，可以提供各個元件共用程式碼。但與 mixin 相比，composable 主要有三個優勢： 第一，元件可以很明確的區分使用的 composable 來源，當使用的 mixin 一多時，追朔來源相對困難，無法一眼看出由哪個 mixin 實作。 第二，多個 mixin 無法確保使用了相同的名稱，可能造成覆蓋，但 composable 即使有相同的名稱，也能透過結構式賦值、重新命名。 最後，多個 mixin 需要交互作用時，通常會使用相同的參數命名來達到這個目的，隱性的耦合使得辨識和debug難度增加，composable可藉由其一的回傳值，作為其他composable輸入的參數達到共享的目的。(參考資料) 開始測試 安裝 Jest 測試 vue 時，首先要注意版本，請參考下面的對照表安裝套件： Vue version Jest Version npm Package Vue 2 Jest 26 and below vue-jest@4 Vue 3 Jest 26 and below vue-jest@5 Vue 2 Jest 27 and above @vue/vue2-jest@27 Vue 3 Jest 27 and above @vue/vue3-jest@27 Vue 2 Jest 28 and above @vue/vue2-jest@28 Vue 3 Jest 28 and above @vue/vue3-jest@28 With lifecyle composable 的測試主要分成兩種，第一種元件比較無關，可以當作普通的 js code 測試。 import {ref} from 'vue'; export function useCounter() { const count = ref(0); const increment = () =&gt; count.value++; return { count, increment, }; }; import {useCounter} from './counter.js'; test('useCounter', () =&gt; { const {count, increment} = useCounter() expect(count.value).toBe(0); increment(); expect(count.value).toBe(1); }); With lifecyle 如果 composable 牽涉到元件 lifecyle hooks 或是 provide/inject 時，需要依附一個元件進行測試。 import {createApp} from 'vue'; export function withSetup(composable) { let result; const app = createApp({ setup() { result = composable(); // suppress missing template warning return () =&gt; {}; }, }); app.mount(document.createElement('div')); // return the result and the app instance // for testing provide / unmount return [result, app]; }; import {ref, onMounted} from 'vue'; export function useCounter() { const count = ref(0); const increment = () =&gt; count.value++; onMounted(() =&gt; { increment(); }); return { count, increment, }; }; result 是 composable 的回傳值(return)，測試裡面 app.mount();，將執行 onMounted： import {withSetup} from './test-utils'; import {useCounter} from './counter.js' test('useCounter', () =&gt; { const [result, app] = withSetup(() =&gt; useCounter()); // run assertions expect(result.count.value).toBe(0); // trigger onMounted hook if needed app.mount(); expect(result.count.value).toBe(1); }); 另外還有一個常犯的錯誤，先看 composable 程式碼，有一個 computed 使用 formatFn 轉換 list： import {computed, unref} from 'vue'; export function useListFormatter(list, formatFn) { const formattedList = computed(() =&gt; ( unref(list).map(item =&gt; formatFn(item)) )); return { formattedList, }; }; 測試時需要注意回傳值被使用之前，formattedList 不會被執行。 import {useListFormatter} from './useListFormatter.js'; test('useListFormatter', () =&gt; { const list = ['a', 'b']; const formatFn = jest.fn(); formatFn.mockImplementation(value =&gt; `new-${value}`) const {formattedList} = useListFormatter(); // Don't do it! formatFn won't be excuted until formattedList is called. // expect(formatFn).toHaveBeenCalled(); expect(formatFn).not.toHaveBeenCalled(); expect(formattedList.value).toEqual(['new-a', 'new-b']); expect(formatFn).toHaveBeenCalledTimes(2); expect(formatFn).toHaveBeenNthCalledWith(1, 'a'); expect(formatFn).toHaveBeenNthCalledWith(2, 'b'); }); 參考資料： https://vuejs.org/guide/scaling-up/testing.html#testing-composables " }, { "title": "webpack 常用 plugin 介紹 - HtmlWebpackPlugin 自動產生 Html", "url": "/posts/vuejs-html-webpack-plugin/", "categories": "Vue.js, Vue, Webpack", "tags": "安裝教學, Webpcak, Webpack5, Node.js, HTML, Javascript, Linux, Vue.js, Vue3, HtmlWebpackPlugin, Plugins", "date": "2022-01-23 16:00:00 +0800", "content": "根據「[Vue.js] 如何建立 Vue3 + webpack5 專案範例」的內容，封裝時已經先建立目錄 dist/ ，新增 index.html，預先將 main.js 加到 script 中。 接著，以下要介紹 HtmlWebpackPlugin ，這個 webpack plugin 可以自動產生 Html，並自動將所有的 js 檔加入 script 中。下面的操作會用 vue3-webpack5-template 這個專案操作，可以先 clone下來並 npm install。 一、安裝 npm install html-webpack-plugin --save-dev 二、新增模板 新增 index.html ，並保留一些區域方便我們可以自訂。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt; &lt;%= htmlWebpackPlugin.options.title %&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"&lt;%= id %&gt;\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 三、新增 Webpack 設定 為了突顯 HtmlWebpackPlugin 功能的強大，首先刻意將輸出的 js 檔案名稱改為 [name].[contenthash].js，這時變得無法預期編譯後的檔案名稱。 再來將 HtmlWebpackPlugin 加入 plugin，完整檔案請點連結 // webpack.config.js const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { output: { filename: '[name].[contenthash].js', path: path.resolve(__dirname, 'dist'), }, ... plugins: [ new HtmlWebpackPlugin({ template: 'template/index.html', title: 'Getting Started', templateParameters: { id: 'app', }, }), ], }; 上面共使用了三個參數： template - 顧名思義是模板的路徑 title - html 檔案的 &lt;title&gt; 也說明為什麼在 index.html 有這一段 &lt;%= htmlWebpackPlugin.options.title %&gt; templateParameters - 這裡傳入一個物件，將 id 訂為 app，因此模板這段程式碼，將會使用這裡的設定複寫 &lt;div id=\"&lt;%= id %&gt;\"&gt;&lt;/div&gt; 若要了解更多參數的使用，可以參考文件。 四、執行 執行下面的指令開始打包 npm run build 程式碼已經 push 到分支 test-webpack-plugin，或者參考變更可以按這裡。 " }, { "title": "Html 轉 Figma 的小工具 Figma Plugin匯入現有網站", "url": "/posts/figma-plugin-html-to-figma/", "categories": "Figma", "tags": "Figma, CSS/SCSS, HTML, Plugins, UI/UX Design", "date": "2021-08-15 16:00:00 +0800", "content": "Figma 如何匯入現有網站，可以使用 Figma to HTML, CSS, React &amp; more! 快速解決！ 可以先安裝 google chrome 的擴充功能、Figma的擴充功能，再到網站使用 google chrome 的擴充功能匯出 Json，並到 Figma 將檔案匯入。 成果雖然會和實際網站有些差別，但很方便。 Figma的擴充功能 Google Chrome 的擴充功能 操作影片 (youtube) " }, { "title": "webpack5 安裝及基礎教學", "url": "/posts/webpack5-getting-started/", "categories": "Vue.js, Webpack", "tags": "安裝教學, Webpcak, Webpack5, Node.js, HTML, Javascript, Linux", "date": "2021-08-08 16:00:00 +0800", "content": "根據維基百科：「Webpack 是一個開源的前端打包工具。Webpack 提供了前端開發缺乏的模組化開發方式，將各種靜態資源視為模組，並從它生成優化過的程式碼。」，使用前必須安裝 Node.js。 webpack 從版本4.0.0開始，可以不需要設定設定檔(webpack.config.js)，設定檔最基本的設定分別是：Entry、Output，前者代表 webpack 必須從哪邊開始進行打包，後者則是定義封裝輸出的路徑以及檔案名稱。 以下參考官網簡單的範例，執行前請先安裝 Node.js，可以參考「安裝node js」替換成需要的版本。 一、安裝 請先新增一個專案目錄，並安裝 webpack、webpack-cli mkdir webpack-demo cd webpack-demo&gt; cd webpack-demo&gt; npm init -y&gt; npm install webpack webpack-cli --save-dev 此時目錄內應該會多一個檔案 package.json 和目錄 node_module/。 二、新增Entry module 新增目錄 src/，以及檔案 index.js const element = document.createElement('div'); element.innerHTML = 'Hello World!'; document.body.appendChild(component()); 三、新增Output 新增目錄 dist/，以及檔案 index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此時的專案架構應該會像是： webpack-demo ├── package.json ├── dist │ └── index.html └── src └── index.js 四、執行 執行下面的指令開始打包 npx webpack 完成後會發現目錄 dist/ 下多了一個檔案 main.js，此時可以開啟 index.html ，看到 Hello World! 就代表打包成功囉！ 在沒有設定檔的情況下，webpack預設會尋找檔名 src 或是目錄 src/ 底下的 index，並將打包好的檔案放到目錄 dist/ 底下，預設檔名是 main.js，等同於： const path = require('path'); module.exports = { entry: './src/index.js', output: { filename: 'main.js', path: path.resolve(__dirname, 'dist'), }, ; 可以透過指令來指定設定檔的路徑及名稱： npx webpack --config webpack.config.js 範例還未使用Loader、Plugin等功能，在這個範例還未使用 css/image，也可以透過 Loader設定處理，另外手動新增 index.html 也可以透過相關的 Plugin 自動產生。 其他進階設定的功能可以參考 https://webpack.js.org/guides/getting-started/ 了解更多。 " }, { "title": "[Vue.js] 如何建立 Vue3 + webpack5 專案範例", "url": "/posts/vue3-webpack5-template/", "categories": "Vue.js, Vue, Webpack", "tags": "Vue.js, Vue3, Webpcak, Webpack5, Node.js, HTML, Javascript, Linux", "date": "2021-08-08 16:00:00 +0800", "content": "以下說明如何使用 webpack5 打包 Vue3 專案，若尚未安裝 webpack 5，可以參考「(webpack5 安裝及基礎教學)[https://chenuin.github.io/webpack/2021/08/08/webpack5-getting-started.html]」。 一、安裝 需要安裝的套件如下，特別需要注意的是，在 Vue3 裡支援副檔名 .vue 的 single-file components 的套件，從 vue-template-compiler 變成 @vue/compiler-sfc： vue @vue/compiler-sfc vue-loader webpack webpack-cli 請先新增專案，並在目錄內新增 package.json，並 npm 執行安裝。 { \"name\": \"vue3-webpack5-template\", \"version\": \"1.0.0\", \"description\": \"vue3-webpack5-template\", \"private\": true, \"scripts\": { \"build\": \"webpack\" }, \"author\": \"chenuin\", \"license\": \"ISC\", \"devDependencies\": { \"@vue/compiler-sfc\": \"^3.1.5\", \"vue-loader\": \"^16.1.2\", \"webpack\": \"^5.49.0\", \"webpack-cli\": \"^4.7.2\" }, \"dependencies\": { \"vue\": \"^3.1.5\" } } 執行指令安裝： npm install 二、設定打包的設定檔 首先針對 Vue 專案所設定的，Loader 可分為test、loader，前者是定義哪些檔案需要處理，像這裡就是副檔名為 .vue 的檔案；後者則是使用哪一個套件處理 ： module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader' }, ], }, plugins: [ new VueLoaderPlugin(), ], 當專案內import vue 可以使用別名(alias)： resolve: { alias: { vue: 'vue/dist/vue.esm-bundler.js', }, }, 因此完整的 webpack.config.js 如下： const path = require('path'); const { VueLoaderPlugin } = require('vue-loader'); module.exports = { entry: './src/index.js', output: { filename: 'main.js', path: path.resolve(__dirname, 'dist'), }, module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader' }, ], }, resolve: { alias: { vue: 'vue/dist/vue.esm-bundler.js', }, }, plugins: [ new VueLoaderPlugin(), ], }; 三、新增Entry, Ouput等內容 在目錄內 src/ 新增兩個檔案: Vue3 主要元件 App.vue &lt;template&gt; &lt;div class=\"app\"&gt; &lt;p v-text=\"msg\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App', setup() { return { msg: 'Hello World!', }; }, }; &lt;/script&gt; 新增 Entry File: index.js 設定別名的用途可以看第一行 import App from './App.vue';。 import { createApp } from 'vue'; import App from './App.vue'; createApp(App) .mount('#app'); 目錄 dist/ 則是新增 index.html，要注意的是先前 index.js 是綁定到 #app，所以 &lt;div id=\"app\"&gt;&lt;/div&gt; 就是 vue render的地方。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Getting Started&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./main.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此時的專案架構應該會像是： webpack-demo ├── package.json ├── dist │ └── index.html └── src ├── App.vue └── index.js 專案已經上傳 Github vue3-webpack5-template，可以下載使用。 四、執行 執行下面的指令開始打包 npx webpack 完成後目錄 dist/ 下多了一個檔案 main.js，此時可以開啟 index.html ，看到 Hello World! 就代表打包成功囉！ " }, { "title": "靜態網頁部落格工具 Ruby + Jekyll 安裝教學", "url": "/posts/jekyll-getting-started/", "categories": "Jekyll", "tags": "安裝教學, Github, HTML, Jekyll, Linux", "date": "2020-05-28 16:00:00 +0800", "content": "一、安裝Ruby 作業系統為Ubuntu 20，指令如下： sudo apt update sudo apt install ruby-full build-essential zlib1g-dev 設定用戶的環境變數，應避免用 root 安裝 Ruby Gems。 echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.bashrc echo 'export GEM_HOME=\"$HOME/gems\"' &gt;&gt; ~/.bashrc echo 'export PATH=\"$HOME/gems/bin:$PATH\"' &gt;&gt; ~/.bashrc source ~/.bashrc 二、安裝Jekyll Ruby中使用Gem作為套件管理的工具，就像是python和pip的關係。安裝套件的方式 gem install [packageName]： gem install jekyll bundler 三、建立新專案 新增一個 myblog 的專案 jekyll new myblog 在目錄下應該會發現新的資料夾 /myblog，大致的內容可以參考一下 ├── 404.html ├── about.markdown ├── _config.yml ├── Gemfile ├── Gemfile.lock ├── index.markdown ├── _posts │ └── 2020-05-27-welcome-to-jekyll.markdown └── _site ├── 404.html ├── about ├── assets ├── feed.xml ├── index.html └── jekyll 四、開啟服務 進入目錄後，啟動伺服器，預設主機名稱 localhost 、埠號 4000，可以根據需求設定： cd myblog bundle exec jekyll serve // or you can ... bundle exec jekyll serve --host=[ip address] --port=[port number] 瀏覽器開啟 http://localhost:4000 ，就可以看到預設的首頁，安裝就告一段落，可以開始進行開發。 " }, { "title": "[Vue.js] v-for設定key的作用與影響", "url": "/posts/vuejs-v-for-key/", "categories": "Vue.js, Vue", "tags": "Vue.js, Javascript, Node.js", "date": "2019-06-16 16:00:00 +0800", "content": "v-for迭代陣列或物件時需要設定key，是為了避免重複產生DOM元素而浪費資源，因此將key視為一個辨識的依據，所有的key必須保持唯一。因此如果key值不小心重複，console甚至會出現 Duplicate keys detected: ... This may cause an update error. 這樣的警示訊息。 為了顯示key的作用和影響，用下面的例子來看，程式內容大意是根據 menu 的內容產生多個 product-box ，兩個唯一的差別是前著用 index 當 key ，後者則是用 id 當作 key，此外多加一個 button 來更動資料的內容。 &lt;template&gt; &lt;div&gt; &lt;product-box v-for=\"item,index in menu\" :key=\"index\" :value=\"item.id\"&gt; &lt;/product-box&gt; &lt;product-box v-for=\"item in menu\" :key=\"item.id\" :value=\"item.id\"&gt; &lt;/product-box&gt; &lt;button @click=\"addFirstElement\"&gt;Add&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ProductBox from './ProductBox' export default { data () { return { menu: [ {id: 'A001', name: 'milk tea'}, {id: 'A002', name: 'juice'} ] } }, methods: { addFirstElement: function() { let first_elm = [{id: 'A000', name: 'coffee'}]; this.menu = first_elm.concat(this.menu); } }, components: { ProductBox } } &lt;/script&gt; ProductBox.vue &lt;template&gt; &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data: function() { return { dispay_text: '' } }, props: { 'value': String }, created: function() { this.dispay_text = this.value; } } &lt;/script&gt; 初始的情況下： A001 milk tea A002 juice 接著，點button在開頭插入一個新的資料，預想的顯示如下，如果用id當作key的話也是產生一樣的結果。 // key=id A000 coffee A001 milk tea A002 juice 這時因為用index當作key，所以原本index 1和2因為沒有偵測到變化並不會重新產生，也就是不會重新經歷created，所以出現所謂的 update error ，結果會變成： // key=index A001 coffee A002 milk tea A002 juice 雖然用index當作key很方便，但並非所有的情況都適合使用index當作key。 " }, { "title": "[Vue.js] 父子元件的雙向溝通示範", "url": "/posts/vuejs-props-emit/", "categories": "Vue.js, Vue", "tags": "Vue.js, Javascript, Node.js", "date": "2019-01-23 16:00:00 +0800", "content": "第一部分、父元件→子元件 利用props將資料傳給components使用 1. 子元件的設定 首先有一個子元件(child component)，我們設定一個 props 為 userName，型態為String，如果data內的參數，你可以直接在模板裡用 `` 印出，或在function內以 this.userName 來進行操作。 template的內容是以顯示 userName 在一個HTML的輸入框裡 // Child Component Vue.component(\"child-input\", { template: ` &lt;div&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input v-model=\"childUserName\" type=\"text\"/&gt; &lt;/div&gt; `, props: { // camelCase in JavaScript userName: String }, data: function() { return { childUserName: this.userName }; } }); ※ Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. 代表Vue會警告你盡量不要直接修改props參數的值，因此我們設定了childUserName來避免這個問題。 2. 父元件的設定 在HTML裡要用user-name來傳值，也就是說component的命名法遵循 camelCase ，到HTML內時則是用 kebab-case 來識別。 user-name和 :user-name 兩者的用法不同，如果是 user-name=\"initial_input\"，會把 “initial_input” 當成字串傳過去，如果前面加上冒號「:」變成 :user-name=\"inital_input\"，則是把 inital_input 這個參數的值傳過去。 &lt;!-- HTML --&gt; &lt;div id=\"app\"&gt; &lt;!-- kebab-case in HTML --&gt; &lt;child-input :user-name=\"initial_input\"&gt;&lt;/child-input&gt; &lt;/div&gt; // js new Vue({ el: \"#app\", data: function() { return { initial_input: \"Annie\", }; } }); 第二部分、子元件→父元件 利用emit將components的資料回傳 1. 子元件的設定 延續第一部分，我們在methods內新增一個 sendToParent 的function，@input=\"sendToParent\" 代表我們觸發的時機。 看一下 sendToParent 內容，$emit 後面第一個參數”update-text“，代表設定一個 update-text 的事件，第二參數是同時把 childUserName 這個參數傳出去，如果需要傳更多的參數，直接用逗號分隔接在後面。 Vue.component(\"child-input\", { template: ` &lt;div class=\"form-group mt-3\"&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input v-model=\"childUserName\" @input=\"sendToParent\" type=\"text\"/&gt; &lt;/div&gt; `, props: { userName: String }, data: function() { return { childUserName: this.userName }; }, methods: { sendToParent: function() { this.$emit(\"update-text\", this.childUserName); } } }); 2. 父元件的設定 父元件的部分也新增一個 getChildText 的function來接收子元件的資料，當子元件觸發’update-text‘時，就會執行 getChildText 來接收傳送的值，value就是從子元件傳來的 childUserName。如果傳多個值，記得在這邊填相應數量的參數來接收。 // JS new Vue({ el: \"#app\", data: function() { return { initial_input: \"Annie\", }; }, methods: { getChildText: function(value) { this.initial_input = value; } } }); &lt;!-- HTML --&gt; &lt;div id=\"app\"&gt; &lt;child-input :user-name=\"initial_input\" @update-text=\"getChildText\"&gt;&lt;/child-input&gt; &lt;/div&gt; 完整的程式碼請參考codepen上的範例：Sending Messages between Parent and Child 相關文章： [Vue.js] 如何在component自訂v-model " } ]
